/**
  JSMat 2.2.1 (ver 2)
   - A JavaScript Library to do Advanced Math.

  EduardoPlayss121.
*/

const JSMat = (function() {
    const PI = Math.PI;
    const TAU = 2 * Math.PI;
    const DEG2RAD = PI / 180;
    const RAD2DEG = 180 / PI;
    const EPSILON = 1e-6;

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const clamp01 = value => clamp(value, 0, 1);
    const sign = value => value >= 0 ? 1 : -1;
    const fract = value => value - Math.floor(value);

    const lerp = (a, b, t) => a + (b - a) * t;
    const inverseLerp = (a, b, value) => (value - a) / (b - a);
    const remap = (value, inMin, inMax, outMin, outMax) => lerp(outMin, outMax, inverseLerp(inMin, inMax, value));

    const easeInSine = t => 1 - Math.cos((t * PI) / 2);
    const easeOutSine = t => Math.sin((t * PI) / 2);
    const easeInOutSine = t => -(Math.cos(PI * t) - 1) / 2;
    const easeInQuad = t => t * t;
    const easeOutQuad = t => 1 - (1 - t) * (1 - t);
    const easeInOutQuad = t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    const easeInCubic = t => t * t * t;
    const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
    const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    const easeInQuart = t => t * t * t * t;
    const easeOutQuart = t => 1 - Math.pow(1 - t, 4);
    const easeInOutQuart = t => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
    const easeInQuint = t => t * t * t * t * t;
    const easeOutQuint = t => 1 - Math.pow(1 - t, 5);
    const easeInOutQuint = t => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
    const easeInExpo = t => t === 0 ? 0 : Math.pow(2, 10 * t - 10);
    const easeOutExpo = t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    const easeInOutExpo = t => {
        if (t === 0) return 0;
        if (t === 1) return 1;
        return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
    };
    const easeInCirc = t => 1 - Math.sqrt(1 - Math.pow(t, 2));
    const easeOutCirc = t => Math.sqrt(1 - Math.pow(t - 1, 2));
    const easeInOutCirc = t => t < 0.5 
        ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 
        : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
    const easeInBack = t => {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return c3 * t * t * t - c1 * t * t;
    };
    const easeOutBack = t => {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    };
    const easeInOutBack = t => {
        const c1 = 1.70158;
        const c2 = c1 * 1.525;
        return t < 0.5
            ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
            : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
    };
    const easeInElastic = t => {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
    };
    const easeOutElastic = t => {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    };
    const easeInOutElastic = t => {
        const c5 = (2 * Math.PI) / 4.5;
        return t === 0 ? 0 : t === 1 ? 1 : t < 0.5
            ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2
            : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 + 1;
    };
    const easeInBounce = t => 1 - easeOutBounce(1 - t);
    const easeOutBounce = t => {
        const n1 = 7.5625;
        const d1 = 2.75;
        if (t < 1 / d1) return n1 * t * t;
        if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
        if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
        return n1 * (t -= 2.625 / d1) * t + 0.984375;
    };
    const easeInOutBounce = t => t < 0.5 
        ? (1 - easeOutBounce(1 - 2 * t)) / 2 
        : (1 + easeOutBounce(2 * t - 1)) / 2;

    const round = (value, decimals = 0) => {
        const factor = Math.pow(10, decimals);
        return Math.round(value * factor) / factor;
    };
    const floor = (value, decimals = 0) => {
        const factor = Math.pow(10, decimals);
        return Math.floor(value * factor) / factor;
    };
    const ceil = (value, decimals = 0) => {
        const factor = Math.pow(10, decimals);
        return Math.ceil(value * factor) / factor;
    };

    const approximately = (a, b, epsilon = EPSILON) => Math.abs(a - b) < epsilon;

    const angleBetween = (a, b) => Math.acos(clamp(dot(normalize(a), normalize(b)), -1, 1));
    const angleBetweenSigned = (a, b, axis) => {
        const angle = angleBetween(a, b);
        const crossProduct = cross(a, b);
        return dot(axis, crossProduct) < 0 ? -angle : angle;
    };
    const degrees = radians => radians * RAD2DEG;
    const radians = degrees => degrees * DEG2RAD;
    const wrapAngle = angle => {
        angle = angle % TAU;
        return angle > PI ? angle - TAU : angle < -PI ? angle + TAU : angle;
    };

    const random = (min = 0, max = 1) => lerp(min, max, Math.random());
    const randomInt = (min, max) => Math.floor(random(min, max + 1));
    const randomSign = () => Math.random() < 0.5 ? -1 : 1;
    const randomFromArray = array => array[randomInt(0, array.length - 1)];
    const randomOnCircle = (radius = 1) => {
        const angle = random(0, TAU);
        return [Math.cos(angle) * radius, Math.sin(angle) * radius];
    };
    const randomInCircle = (radius = 1) => {
        const angle = random(0, TAU);
        const r = Math.sqrt(random(0, 1)) * radius;
        return [Math.cos(angle) * r, Math.sin(angle) * r];
    };
    const randomOnSphere = (radius = 1) => {
        const u = random(-1, 1);
        const t = random(0, TAU);
        const f = Math.sqrt(1 - u * u);
        return [
            radius * f * Math.cos(t),
            radius * f * Math.sin(t),
            radius * u
        ];
    };
    const randomInSphere = (radius = 1) => {
        const u = random(-1, 1);
        const t = random(0, TAU);
        const r = Math.cbrt(random(0, 1)) * radius;
        const f = Math.sqrt(1 - u * u);
        return [
            r * f * Math.cos(t),
            r * f * Math.sin(t),
            r * u
        ];
    };

    const vec2 = (x = 0, y = 0) => [x, y];
    const vec2Add = (a, b) => [a[0] + b[0], a[1] + b[1]];
    const vec2Sub = (a, b) => [a[0] - b[0], a[1] - b[1]];
    const vec2Mul = (a, b) => [a[0] * b[0], a[1] * b[1]];
    const vec2Div = (a, b) => [a[0] / b[0], a[1] / b[1]];
    const vec2Scale = (a, s) => [a[0] * s, a[1] * s];
    const vec2Dot = (a, b) => a[0] * b[0] + a[1] * b[1];
    const vec2Cross = (a, b) => a[0] * b[1] - a[1] * b[0];
    const vec2Length = a => Math.sqrt(vec2Dot(a, a));
    const vec2Distance = (a, b) => vec2Length(vec2Sub(a, b));
    const vec2Normalize = a => {
        const len = vec2Length(a);
        return len > 0 ? vec2Scale(a, 1 / len) : [0, 0];
    };
    const vec2Lerp = (a, b, t) => [lerp(a[0], b[0], t), lerp(a[1], b[1], t)];
    const vec2Angle = a => Math.atan2(a[1], a[0]);
    const vec2Rotate = (a, angle) => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [a[0] * c - a[1] * s, a[0] * s + a[1] * c];
    };
    const vec2Perpendicular = a => [a[1], -a[0]];
    const vec2Reflect = (a, normal) => {
        const dot = vec2Dot(a, normal);
        return [a[0] - 2 * dot * normal[0], a[1] - 2 * dot * normal[1]];
    };
    const vec2Project = (a, b) => {
        const denom = vec2Dot(b, b);
        return denom > 0 ? vec2Scale(b, vec2Dot(a, b) / denom) : [0, 0];
    };
    const vec2Reject = (a, b) => vec2Sub(a, vec2Project(a, b));
    const vec2Equals = (a, b, epsilon = EPSILON) => 
        approximately(a[0], b[0], epsilon) && approximately(a[1], b[1], epsilon);

    const vec3 = (x = 0, y = 0, z = 0) => [x, y, z];
    const vec3Add = (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
    const vec3Sub = (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    const vec3Mul = (a, b) => [a[0] * b[0], a[1] * b[1], a[2] * b[2]];
    const vec3Div = (a, b) => [a[0] / b[0], a[1] / b[1], a[2] / b[2]];
    const vec3Scale = (a, s) => [a[0] * s, a[1] * s, a[2] * s];
    const vec3Dot = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    const vec3Cross = (a, b) => [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
    ];
    const vec3Length = a => Math.sqrt(vec3Dot(a, a));
    const vec3Distance = (a, b) => vec3Length(vec3Sub(a, b));
    const vec3Normalize = a => {
        const len = vec3Length(a);
        return len > 0 ? vec3Scale(a, 1 / len) : [0, 0, 0];
    };
    const vec3Lerp = (a, b, t) => [lerp(a[0], b[0], t), lerp(a[1], b[1], t), lerp(a[2], b[2], t)];
    const vec3Angle = (a, b) => Math.acos(clamp(vec3Dot(vec3Normalize(a), vec3Normalize(b)), -1, 1));
    const vec3RotateX = (a, angle) => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [a[0], a[1] * c - a[2] * s, a[1] * s + a[2] * c];
    };
    const vec3RotateY = (a, angle) => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [a[0] * c + a[2] * s, a[1], -a[0] * s + a[2] * c];
    };
    const vec3RotateZ = (a, angle) => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [a[0] * c - a[1] * s, a[0] * s + a[1] * c, a[2]];
    };
    const vec3Reflect = (a, normal) => {
        const dot = vec3Dot(a, normal);
        return [
            a[0] - 2 * dot * normal[0],
            a[1] - 2 * dot * normal[1],
            a[2] - 2 * dot * normal[2]
        ];
    };
    const vec3Project = (a, b) => {
        const denom = vec3Dot(b, b);
        return denom > 0 ? vec3Scale(b, vec3Dot(a, b) / denom) : [0, 0, 0];
    };
    const vec3Reject = (a, b) => vec3Sub(a, vec3Project(a, b));
    const vec3Equals = (a, b, epsilon = EPSILON) => 
        approximately(a[0], b[0], epsilon) && 
        approximately(a[1], b[1], epsilon) && 
        approximately(a[2], b[2], epsilon);

    const vec4 = (x = 0, y = 0, z = 0, w = 0) => [x, y, z, w];
    const vec4Add = (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3]];
    const vec4Sub = (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2], a[3] - b[3]];
    const vec4Mul = (a, b) => [a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3]];
    const vec4Div = (a, b) => [a[0] / b[0], a[1] / b[1], a[2] / b[2], a[3] / b[3]];
    const vec4Scale = (a, s) => [a[0] * s, a[1] * s, a[2] * s, a[3] * s];
    const vec4Dot = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    const vec4Length = a => Math.sqrt(vec4Dot(a, a));
    const vec4Distance = (a, b) => vec4Length(vec4Sub(a, b));
    const vec4Normalize = a => {
        const len = vec4Length(a);
        return len > 0 ? vec4Scale(a, 1 / len) : [0, 0, 0, 0];
    };
    const vec4Lerp = (a, b, t) => [
        lerp(a[0], b[0], t),
        lerp(a[1], b[1], t),
        lerp(a[2], b[2], t),
        lerp(a[3], b[3], t)
    ];
    const vec4Equals = (a, b, epsilon = EPSILON) => 
        approximately(a[0], b[0], epsilon) && 
        approximately(a[1], b[1], epsilon) && 
        approximately(a[2], b[2], epsilon) && 
        approximately(a[3], b[3], epsilon);

    const mat2 = () => [1, 0, 0, 1];
    const mat2FromRotation = angle => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [c, -s, s, c];
    };
    const mat2Multiply = (a, b) => [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3]
    ];
    const mat2MultiplyVec2 = (m, v) => [
        m[0] * v[0] + m[2] * v[1],
        m[1] * v[0] + m[3] * v[1]
    ];
    const mat2Determinant = m => m[0] * m[3] - m[1] * m[2];
    const mat2Inverse = m => {
        const det = mat2Determinant(m);
        return det !== 0 ? [
             m[3] / det, -m[1] / det,
            -m[2] / det,  m[0] / det
        ] : [0, 0, 0, 0];
    };

    const mat3 = () => [1, 0, 0, 0, 1, 0, 0, 0, 1];
    const mat3FromRotationX = angle => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [1, 0, 0, 0, c, -s, 0, s, c];
    };
    const mat3FromRotationY = angle => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [c, 0, s, 0, 1, 0, -s, 0, c];
    };
    const mat3FromRotationZ = angle => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [c, -s, 0, s, c, 0, 0, 0, 1];
    };
    const mat3Multiply = (a, b) => [
        a[0] * b[0] + a[3] * b[1] + a[6] * b[2],
        a[1] * b[0] + a[4] * b[1] + a[7] * b[2],
        a[2] * b[0] + a[5] * b[1] + a[8] * b[2],
        a[0] * b[3] + a[3] * b[4] + a[6] * b[5],
        a[1] * b[3] + a[4] * b[4] + a[7] * b[5],
        a[2] * b[3] + a[5] * b[4] + a[8] * b[5],
        a[0] * b[6] + a[3] * b[7] + a[6] * b[8],
        a[1] * b[6] + a[4] * b[7] + a[7] * b[8],
        a[2] * b[6] + a[5] * b[7] + a[8] * b[8]
    ];
    const mat3MultiplyVec3 = (m, v) => [
        m[0] * v[0] + m[3] * v[1] + m[6] * v[2],
        m[1] * v[0] + m[4] * v[1] + m[7] * v[2],
        m[2] * v[0] + m[5] * v[1] + m[8] * v[2]
    ];
    const mat3Determinant = m => 
        m[0] * (m[4] * m[8] - m[5] * m[7]) -
        m[3] * (m[1] * m[8] - m[2] * m[7]) +
        m[6] * (m[1] * m[5] - m[2] * m[4]);
    const mat3Inverse = m => {
        const det = mat3Determinant(m);
        if (det === 0) return mat3();
        
        const invDet = 1 / det;
        return [
            (m[4] * m[8] - m[5] * m[7]) * invDet,
            (m[2] * m[7] - m[1] * m[8]) * invDet,
            (m[1] * m[5] - m[2] * m[4]) * invDet,
            (m[5] * m[6] - m[3] * m[8]) * invDet,
            (m[0] * m[8] - m[2] * m[6]) * invDet,
            (m[2] * m[3] - m[0] * m[5]) * invDet,
            (m[3] * m[7] - m[4] * m[6]) * invDet,
            (m[1] * m[6] - m[0] * m[7]) * invDet,
            (m[0] * m[4] - m[1] * m[3]) * invDet
        ];
    };

    const mat4 = () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    const mat4FromTranslation = v => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1];
    const mat4FromRotationX = angle => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1];
    };
    const mat4FromRotationY = angle => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1];
    };
    const mat4FromRotationZ = angle => {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        return [c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    };
    const mat4FromScaling = v => [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1];
    const mat4FromPerspective = (fovy, aspect, near, far) => {
        const f = 1 / Math.tan(fovy / 2);
        const nf = 1 / (near - far);
        return [
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (far + near) * nf, -1,
            0, 0, 2 * far * near * nf, 0
        ];
    };
    const mat4FromOrthographic = (left, right, bottom, top, near, far) => {
        const lr = 1 / (left - right);
        const bt = 1 / (bottom - top);
        const nf = 1 / (near - far);
        return [
            -2 * lr, 0, 0, 0,
            0, -2 * bt, 0, 0,
            0, 0, 2 * nf, 0,
            (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1
        ];
    };
    const mat4LookAt = (eye, center, up) => {
        const z = vec3Normalize(vec3Sub(eye, center));
        const x = vec3Normalize(vec3Cross(up, z));
        const y = vec3Normalize(vec3Cross(z, x));
        
        return [
            x[0], y[0], z[0], 0,
            x[1], y[1], z[1], 0,
            x[2], y[2], z[2], 0,
            -vec3Dot(x, eye), -vec3Dot(y, eye), -vec3Dot(z, eye), 1
        ];
    };
    const mat4Multiply = (a, b) => {
        const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        
        const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
        const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
        const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
        const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
        
        return [
            b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
            b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
            b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
            b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
            
            b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
            b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
            b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
            b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
            
            b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
            b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
            b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
            b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
            
            b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
            b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
            b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
            b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
        ];
    };
    const mat4MultiplyVec4 = (m, v) => [
        m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],
        m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],
        m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],
        m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]
    ];
    const mat4Transpose = m => [
        m[0], m[4], m[8], m[12],
        m[1], m[5], m[9], m[13],
        m[2], m[6], m[10], m[14],
        m[3], m[7], m[11], m[15]
    ];
    const mat4Determinant = m => {
        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
        
        return (
            m03 * m12 * m21 * m30 - m02 * m13 * m21 * m30 -
            m03 * m11 * m22 * m30 + m01 * m13 * m22 * m30 +
            m02 * m11 * m23 * m30 - m01 * m12 * m23 * m30 -
            m03 * m12 * m20 * m31 + m02 * m13 * m20 * m31 +
            m03 * m10 * m22 * m31 - m00 * m13 * m22 * m31 -
            m02 * m10 * m23 * m31 + m00 * m12 * m23 * m31 +
            m03 * m11 * m20 * m32 - m01 * m13 * m20 * m32 -
            m03 * m10 * m21 * m32 + m00 * m13 * m21 * m32 +
            m01 * m10 * m23 * m32 - m00 * m11 * m23 * m32 -
            m02 * m11 * m20 * m33 + m01 * m12 * m20 * m33 +
            m02 * m10 * m21 * m33 - m00 * m12 * m21 * m33 -
            m01 * m10 * m22 * m33 + m00 * m11 * m22 * m33
        );
    };
    const mat4Inverse = m => {
        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
        
        const tmp0 = m22 * m33;
        const tmp1 = m32 * m23;
        const tmp2 = m12 * m33;
        const tmp3 = m32 * m13;
        const tmp4 = m12 * m23;
        const tmp5 = m22 * m13;
        const tmp6 = m02 * m33;
        const tmp7 = m32 * m03;
        const tmp8 = m02 * m23;
        const tmp9 = m22 * m03;
        const tmp10 = m02 * m13;
        const tmp11 = m12 * m03;
        const tmp12 = m20 * m31;
        const tmp13 = m30 * m21;
        const tmp14 = m10 * m31;
        const tmp15 = m30 * m11;
        const tmp16 = m10 * m21;
        const tmp17 = m20 * m11;
        const tmp18 = m00 * m31;
        const tmp19 = m30 * m01;
        const tmp20 = m00 * m21;
        const tmp21 = m20 * m01;
        const tmp22 = m00 * m11;
        const tmp23 = m10 * m01;
        
        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) - (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) - (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) - (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) - (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
        
        const det = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        
        return [
            det * t0,
            det * t1,
            det * t2,
            det * t3,
            
            det * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
            det * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
            det * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
            det * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
            
            det * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
            det * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
            det * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
            det * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
            
            det * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
            det * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
            det * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
            det * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02))
        ];
    };

    const quat = (x = 0, y = 0, z = 0, w = 1) => [x, y, z, w];
    const quatFromAxisAngle = (axis, angle) => {
        const halfAngle = angle / 2;
        const s = Math.sin(halfAngle);
        return [
            axis[0] * s,
            axis[1] * s,
            axis[2] * s,
            Math.cos(halfAngle)
        ];
    };
    const quatFromEuler = (x, y, z) => {
        const c1 = Math.cos(x / 2);
        const c2 = Math.cos(y / 2);
        const c3 = Math.cos(z / 2);
        const s1 = Math.sin(x / 2);
        const s2 = Math.sin(y / 2);
        const s3 = Math.sin(z / 2);
        
        return [
            s1 * c2 * c3 + c1 * s2 * s3,
            c1 * s2 * c3 - s1 * c2 * s3,
            c1 * c2 * s3 + s1 * s2 * c3,
            c1 * c2 * c3 - s1 * s2 * s3
        ];
    };
    const quatMultiply = (a, b) => [
        a[3] * b[0] + a[0] * b[3] + a[1] * b[2] - a[2] * b[1],
        a[3] * b[1] - a[0] * b[2] + a[1] * b[3] + a[2] * b[0],
        a[3] * b[2] + a[0] * b[1] - a[1] * b[0] + a[2] * b[3],
        a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2]
    ];
    const quatConjugate = q => [-q[0], -q[1], -q[2], q[3]];
    const quatInverse = q => {
        const lenSq = q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3];
        if (lenSq === 0) return [0, 0, 0, 1];
        const invLenSq = 1 / lenSq;
        return [-q[0] * invLenSq, -q[1] * invLenSq, -q[2] * invLenSq, q[3] * invLenSq];
    };
    const quatNormalize = q => {
        const len = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
        return len > 0 ? [q[0] / len, q[1] / len, q[2] / len, q[3] / len] : [0, 0, 0, 1];
    };
    const quatLerp = (a, b, t) => [
        lerp(a[0], b[0], t),
        lerp(a[1], b[1], t),
        lerp(a[2], b[2], t),
        lerp(a[3], b[3], t)
    ];
    const quatSlerp = (a, b, t) => {
        let cosHalfTheta = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        
        if (cosHalfTheta < 0) {
            b = [-b[0], -b[1], -b[2], -b[3]];
            cosHalfTheta = -cosHalfTheta;
        }
        
        if (Math.abs(cosHalfTheta) >= 1) {
            return [a[0], a[1], a[2], a[3]];
        }
        
        const halfTheta = Math.acos(cosHalfTheta);
        const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
        
        if (Math.abs(sinHalfTheta) < EPSILON) {
            return [
                0.5 * (a[0] + b[0]),
                0.5 * (a[1] + b[1]),
                0.5 * (a[2] + b[2]),
                0.5 * (a[3] + b[3])
            ];
        }
        
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
        const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        
        return [
            a[0] * ratioA + b[0] * ratioB,
            a[1] * ratioA + b[1] * ratioB,
            a[2] * ratioA + b[2] * ratioB,
            a[3] * ratioA + b[3] * ratioB
        ];
    };
    const quatToMat4 = q => {
        const x = q[0], y = q[1], z = q[2], w = q[3];
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        
        return [
            1 - (yy + zz), xy - wz, xz + wy, 0,
            xy + wz, 1 - (xx + zz), yz - wx, 0,
            xz - wy, yz + wx, 1 - (xx + yy), 0,
            0, 0, 0, 1
        ];
    };

    const simplex = (() => {
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;
        const F3 = 1 / 3;
        const G3 = 1 / 6;
        
        const grad3 = [
            [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
            [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
            [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
        ];
        
        const p = [
            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,
            8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
            35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
            134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,
            55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
            18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,
            250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
            189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
            172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
            228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
            49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138,
            236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
        ];
        
        const perm = new Array(512);
        const gradP = new Array(512);
        
        for (let i = 0; i < 512; i++) {
            perm[i] = p[i & 255];
            gradP[i] = grad3[perm[i] % 12];
        }
        
        const dot = (g, x, y) => g[0] * x + g[1] * y;
        
        return (xin, yin) => {
            let n0, n1, n2;
            
            const s = (xin + yin) * F2;
            const i = Math.floor(xin + s);
            const j = Math.floor(yin + s);
            
            const t = (i + j) * G2;
            const x0 = xin - (i - t);
            const y0 = yin - (j - t);
            
            let i1, j1;
            if (x0 > y0) {
                i1 = 1;
                j1 = 0;
            } else {
                i1 = 0;
                j1 = 1;
            }
            
            const x1 = x0 - i1 + G2;
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1 + 2 * G2;
            const y2 = y0 - 1 + 2 * G2;
            
            const ii = i & 255;
            const jj = j & 255;
            
            let t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 >= 0) {
                t0 *= t0;
                n0 = t0 * t0 * dot(gradP[ii + perm[jj]], x0, y0);
            }
            
            let t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 >= 0) {
                t1 *= t1;
                n1 = t1 * t1 * dot(gradP[ii + i1 + perm[jj + j1]], x1, y1);
            }
            
            let t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 >= 0) {
                t2 *= t2;
                n2 = t2 * t2 * dot(gradP[ii + 1 + perm[jj + 1]], x2, y2);
            }
            
            return 70 * (n0 + n1 + n2);
        };
    })();

    const bezier = (p0, p1, p2, p3, t) => {
        const mt = 1 - t;
        const mt2 = mt * mt;
        const t2 = t * t;
        
        return p0 * mt2 * mt + 
               p1 * 3 * mt2 * t + 
               p2 * 3 * mt * t2 + 
               p3 * t2 * t;
    };

    const quadraticBezier = (p0, p1, p2, t) => {
        const mt = 1 - t;
        return mt * mt * p0 + 2 * mt * t * p1 + t * t * p2;
    };
    
    const catmullRom = (p0, p1, p2, p3, t, tension = 0.5) => {
        const t2 = t * t;
        const t3 = t2 * t;
        
        return 0.5 * (
            (2 * p1) +
            (-p0 + p2) * t +
            (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
            (-p0 + 3 * p1 - 3 * p2 + p3) * t3
        ) * tension;
    };
    
    const hermite = (p0, p1, t0, t1, t) => {
        const t2 = t * t;
        const t3 = t2 * t;
        
        const h1 = 2 * t3 - 3 * t2 + 1;
        const h2 = -2 * t3 + 3 * t2;
        const h3 = t3 - 2 * t2 + t;
        const h4 = t3 - t2;
        
        return h1 * p0 + h2 * p1 + h3 * t0 + h4 * t1;
    };

    const pointInCircle = (point, center, radius) => {
        const dx = point[0] - center[0];
        const dy = point[1] - center[1];
        return dx * dx + dy * dy <= radius * radius;
    };
    
    const pointInRect = (point, rect) => {
        return point[0] >= rect[0] && 
               point[0] <= rect[0] + rect[2] && 
               point[1] >= rect[1] && 
               point[1] <= rect[1] + rect[3];
    };
    
    const lineIntersectsLine = (a1, a2, b1, b2) => {
        const denominator = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);
        
        if (denominator === 0) return null; // Lines are parallel
        
        const ua = ((b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0])) / denominator;
        const ub = ((a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0])) / denominator;
        
        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
    };
    
    const lineIntersectsCircle = (a, b, center, radius) => {
        const ac = [center[0] - a[0], center[1] - a[1]];
        const ab = [b[0] - a[0], b[1] - a[1]];
        const ab2 = vec2Dot(ab, ab);
        const acab = vec2Dot(ac, ab);
        let t = acab / ab2;
        
        t = clamp(t, 0, 1);
        const h = [ab[0] * t + a[0] - center[0], ab[1] * t + a[1] - center[1]];
        const h2 = vec2Dot(h, h);
        
        return h2 <= radius * radius;
    };

    const smoothstep = (min, max, value) => {
        const x = clamp((value - min) / (max - min), 0, 1);
        return x * x * (3 - 2 * x);
    };
    
    const smootherstep = (min, max, value) => {
        const x = clamp((value - min) / (max - min), 0, 1);
        return x * x * x * (x * (x * 6 - 15) + 10);
    };
    
    const pingPong = (t, length) => length - Math.abs(fract(t / (length * 2)) * length * 2 - length);

    const rgbToHsv = (r, g, b) => {
        r /= 255; g /= 255; b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const delta = max - min;
        
        let h, s, v = max;
        
        if (delta === 0) {
            h = 0;
            s = 0;
        } else {
            s = delta / max;
            
            if (max === r) {
                h = (g - b) / delta + (g < b ? 6 : 0);
            } else if (max === g) {
                h = (b - r) / delta + 2;
            } else {
                h = (r - g) / delta + 4;
            }
            
            h /= 6;
        }
        
        return [h * 360, s * 100, v * 100];
    };
    
    const hsvToRgb = (h, s, v) => {
        h = (h % 360) / 60;
        s /= 100;
        v /= 100;
        
        const i = Math.floor(h);
        const f = h - i;
        const p = v * (1 - s);
        const q = v * (1 - s * f);
        const t = v * (1 - s * (1 - f));
        
        let r, g, b;
        
        switch (i) {
            case 0: r = v; g = t; b = p; break;
            case 1: r = q; g = v; b = p; break;
            case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break;
            case 4: r = t; g = p; b = v; break;
            default: r = v; g = p; b = q;
        }
        
        return [r * 255, g * 255, b * 255];
    };

    return {
        // Constants
        PI, TAU, DEG2RAD, RAD2DEG, EPSILON,
        
        // Basic Utils
        clamp, clamp01, sign, fract, round, floor, ceil, approximately,
        
        // interpolation
        lerp, inverseLerp, remap,
        
        // Easing
        easeInSine, easeOutSine, easeInOutSine,
        easeInQuad, easeOutQuad, easeInOutQuad,
        easeInCubic, easeOutCubic, easeInOutCubic,
        easeInQuart, easeOutQuart, easeInOutQuart,
        easeInQuint, easeOutQuint, easeInOutQuint,
        easeInExpo, easeOutExpo, easeInOutExpo,
        easeInCirc, easeOutCirc, easeInOutCirc,
        easeInBack, easeOutBack, easeInOutBack,
        easeInElastic, easeOutElastic, easeInOutElastic,
        easeInBounce, easeOutBounce, easeInOutBounce,
        
        // Angles
        angleBetween, angleBetweenSigned, degrees, radians, wrapAngle,
        
        // Randomness
        random, randomInt, randomSign, randomFromArray,
        randomOnCircle, randomInCircle, randomOnSphere, randomInSphere,
        
        // Vectors
        vec2, vec2Add, vec2Sub, vec2Mul, vec2Div, vec2Scale, vec2Dot, vec2Cross,
        vec2Length, vec2Distance, vec2Normalize, vec2Lerp, vec2Angle, vec2Rotate,
        vec2Perpendicular, vec2Reflect, vec2Project, vec2Reject, vec2Equals,
        
        vec3, vec3Add, vec3Sub, vec3Mul, vec3Div, vec3Scale, vec3Dot, vec3Cross,
        vec3Length, vec3Distance, vec3Normalize, vec3Lerp, vec3Angle, vec3RotateX,
        vec3RotateY, vec3RotateZ, vec3Reflect, vec3Project, vec3Reject, vec3Equals,
        
        vec4, vec4Add, vec4Sub, vec4Mul, vec4Div, vec4Scale, vec4Dot, vec4Length,
        vec4Distance, vec4Normalize, vec4Lerp, vec4Equals,
        
        // Matrices
        mat2, mat2FromRotation, mat2Multiply, mat2MultiplyVec2, mat2Determinant, mat2Inverse,
        mat3, mat3FromRotationX, mat3FromRotationY, mat3FromRotationZ, mat3Multiply,
        mat3MultiplyVec3, mat3Determinant, mat3Inverse,
        mat4, mat4FromTranslation, mat4FromRotationX, mat4FromRotationY, mat4FromRotationZ,
        mat4FromScaling, mat4FromPerspective, mat4FromOrthographic, mat4LookAt,
        mat4Multiply, mat4MultiplyVec4, mat4Transpose, mat4Determinant, mat4Inverse,
        
        // Quaternions
        quat, quatFromAxisAngle, quatFromEuler, quatMultiply, quatConjugate,
        quatInverse, quatNormalize, quatLerp, quatSlerp, quatToMat4,
        
        // Noise
        simplex,
        
        // Splines and more
        bezier, quadraticBezier, catmullRom, hermite,
        
        // Geometry
        pointInCircle, pointInRect, lineIntersectsLine, lineIntersectsCircle,
        
        // Utils
        smoothstep, smootherstep, pingPong,
        
        // Colors
        rgbToHsv, hsvToRgb
    };
})();

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = JSMat;
} else if (typeof window !== 'undefined') {
    window.JSMat2 = JSMat;
} else if (typeof self !== 'undefined') {
    self._JSMat_ = JSMat;
}
